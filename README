SYNOPSIS
        use Mock::Sub;

        my $foo = Mock::Sub->mock('Package::foo');
        my $bar = Mock::Sub->mock('Package::bar');
        my $baz = Mock::Sub->mock('Package::baz');

        # wait until the mocked sub is called

        Package::foo();

        # then...

        $foo->name;         # name of sub that's mocked
        $foo->called;       # was the sub called?
        $foo->call_count;   # how many times was it called?

        # create a mock object to reduce typing

        my $mock = Mock::Sub->new;
    
        my $foo = $mock->('Package::foo');
        my $bar = $mock->('Package::bar');
        my $baz = $mock->('Package::baz');

        # have the mocked sub return something when it's called

        $foo = $mock->('Package::foo', return_value => 'True');

        # have the mocked sub perform an action

        $foo = $mock->('Package::foo', side_effect => sub { die "eval catch"; });
    
EXAMPLE
    Here's a full example to get further coverage where it's difficult if
    not impossible to test certain areas of your code (eg: you have if/else
    statements, but they don't do anything but call other subs. You don't
    want to test the subs that are called, nor do you want to add statements
    to your code).

    Note that if the end subroutine you're testing is NOT Object Oriented
    (and you're importing them into your module that you're testing), you
    have to mock them as part of your own namespace (ie. instead of
    Other::first, you'd mock MyModule::first).

       # module you're testing:

        package MyPackage;
    
        use Other;
        use Exporter qw(import);
        @EXPORT_OK = qw(test);
   
        my $other = Other->new;

        sub test {
            my $arg = shift;
        
            if ($arg == 1){
                # how do you test this... there's no return etc.
                $other->first();        
            }
            if ($arg == 2){
                $other->second();
            }
        }

        # your test file

        use MyPackage qw(test);
        use Mock::Sub;
        use Test::More tests => 2;

        my $mock = Mock::Sub->new;

        my $first = $mock->mock('Other::first');
        my $second = $mock->mock('Other::second');

        # coverage for first if() in MyPackage::test
        test(1);
        is ($first->called, 1, "first if() covered");

        # coverage for second if()
        test(2);
        is ($second->called, 1, "first if() covered");

METHODS
  `new'
    Instantiates and returns a new Mock::Sub object.

  `mock('sub', %opts)'
    Instantiates a new object on each call. 'sub' is the name of the
    subroutine to mock (requires full package name if the sub isn't in
    `main::').

    Options:

    return_value: Set this to have the mocked sub return anything you wish.

    side_effect: Send in a code reference containing an action you'd like
    the mocked sub to perform (`die()' is useful for testing with `eval()').

    Note that only one of these parameters may be sent in at a time.

  `called'
    Returns true if the sub being mocked has been called.

  `call_count'
    Returns the number of times the mocked sub has been called.

  `name'
    Returns the full name of the sub being mocked, as entered into `mock()'.

  `reset'
    Resets the functional parameters (`return_value', `side_effect'), along
    with `called()' and `call_count' back to undef/untrue.

AUTHOR
    Steve Bertrand, `<steveb at cpan.org>'

BUGS
    Please report any bugs or feature requests to `bug-test-mocksub at
    rt.cpan.org', or through the web interface at
    http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-MockSub. I will be
    notified, and then you'll automatically be notified of progress on your
    bug as I make changes.

SUPPORT
    You can find documentation for this module with the perldoc command.

        perldoc Mock::Sub

    You can also look for information at:

    * RT: CPAN's request tracker (report bugs here)
        http://rt.cpan.org/NoAuth/Bugs.html?Dist=Test-MockSub

ACKNOWLEDGEMENTS
    Python's MagicMock module.

LICENSE AND COPYRIGHT
    Copyright 2015 Steve Bertrand.

    This program is free software; you can redistribute it and/or modify it
    under the terms of either: the GNU General Public License as published
    by the Free Software Foundation; or the Artistic License.

    See http://dev.perl.org/licenses/ for more information.

